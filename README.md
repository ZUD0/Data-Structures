<h1>📘 <span style="color:#007acc">Data Structures & Algorithms – From Scratch</span></h1>

<p>This repository is a <b>from-scratch</b> implementation of fundamental data structures and their classical problems & algorithms.<br>
<i>Goal:</i> <span style="color:#2ecc40">mastery</span> — not just using STL/Java Collections/Python built-ins, but <b>building</b>, <b>understanding</b>, and <b>applying</b> them.</p>

<h2>📂 Table of Contents</h2>

<ul>
	<li>🟦 <b>Arrays</b></li>
	<li>🟩 <b>Linked Lists</b></li>
	<li>🟧 <b>Stacks</b></li>
	<li>🟨 <b>Queues</b></li>
	<li>🟪 <b>Heaps</b></li>
	<li>🌳 <b>Binary Trees</b></li>
	<li>🌲 <b>Binary Search Trees</b></li>
	<li>🕸️ <b>Graphs</b></li>
</ul>

<h3>🔹 1. Arrays</h3>

<b>Implementation:</b>
<ul>
	<li>Static & dynamic arrays</li>
	<li>Insert, delete, search, resize</li>
</ul>

<b>Classical Problems:</b>
<ul>
	<li>🔄 Reverse array</li>
	<li>🔁 Rotate array (k steps)</li>
	<li>❓ Find missing number (1..n)</li>
	<li>➕ Two Sum / Subarray sum</li>
	<li>💪 Kadane’s algorithm (max subarray sum)</li>
	<li>📊 Prefix sum problems</li>
</ul>

<b>Algorithms:</b>
<ul>
	<li>🪟 Sliding Window</li>
	<li>🔍 Binary Search (and variants: first/last occurrence, upper/lower bound)</li>
	<li>🧮 Sorting (Quicksort, Mergesort)</li>
</ul>

<h3>🔹 2. Linked Lists</h3>

<b>Implementation:</b>
<ul>
	<li>Singly, Doubly, Circular LL</li>
	<li>Insert at head/tail/pos, delete, search</li>
</ul>

Classical Problems:

Reverse linked list (iterative + recursive)

Detect cycle (Floyd’s algo)

Merge two sorted lists

Remove nth node from end

Find middle node

LRU Cache (LL + HashMap)

Algorithms:

Fast/slow pointer (Cycle detection)

Mergesort on Linked List

🔹 3. Stacks

Implementation:

Array-based stack

Linked list stack

Classical Problems:

Balanced parentheses

Next greater element

Min stack (O(1) min)

Evaluate postfix/prefix expression

Largest rectangle in histogram

Algorithms:

Monotonic stack

Infix → Postfix conversion

🔹 4. Queues

Implementation:

Array queue (circular queue)

Linked list queue

Deque (double-ended queue)

Classical Problems:

Implement stack using queues

Implement queue using stacks

Sliding window maximum (deque)

Rotten oranges (BFS)

First non-repeating character in stream

Algorithms:

BFS (graph/grid traversal)

Sliding window

🔹 5. Heaps (Priority Queue)

Implementation:

Min-heap & Max-heap

Heapify, insert, extract

Classical Problems:

Heap sort

Kth largest/smallest element

Merge k sorted arrays/lists

Top K frequent elements

Median of data stream

Algorithms:

Heapify (O(n))

Priority queue scheduling

🔹 6. Binary Trees

Implementation:

Node structure

Recursive/iterative traversals

Classical Problems:

Inorder, Preorder, Postorder, Level Order

Height/Depth of tree

Diameter of tree

Lowest Common Ancestor (LCA)

Path sum problems

Serialize & Deserialize tree

Algorithms:

DFS (recursive & iterative)

BFS level-order

Recursion + backtracking

🔹 7. Binary Search Trees (BST)

Implementation:

Insert, search, delete

Traversals

Classical Problems:

Validate BST

Kth smallest/largest element

LCA in BST

Convert sorted array to BST

Floor & Ceil in BST

Algorithms:

Inorder traversal = sorted order

Self-balancing trees (AVL, Red-Black – advanced)

🔹 8. Graphs

Implementation:

Adjacency list & matrix

Directed / Undirected

Weighted / Unweighted

Classical Problems:

DFS, BFS

Cycle detection (directed/undirected)

Topological sort (DFS + Kahn’s algo)

Shortest path: Dijkstra, Bellman-Ford

Minimum Spanning Tree: Kruskal, Prim

Connected components (Union-Find, DFS)

Bipartite check

Bridges & articulation points (Tarjan’s algo)

Algorithms:

Union-Find (DSU)

Dijkstra, Bellman-Ford, Floyd-Warshall

Kruskal, Prim

Tarjan’s SCC

Kosaraju’s SCC

✅ Goal

Implement all data structures from scratch

Solve their classical problems

Master the algorithms built on top