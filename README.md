<h1>ğŸ“˜ <span style="color:#007acc">Data Structures & Algorithms â€“ From Scratch</span></h1>

<p>This repository is a <b>from-scratch</b> implementation of fundamental data structures and their classical problems & algorithms.<br>
<i>Goal:</i> <span style="color:#2ecc40">mastery</span> â€” not just using STL/Java Collections/Python built-ins, but <b>building</b>, <b>understanding</b>, and <b>applying</b> them.</p>

<h2>ğŸ“‚ Table of Contents</h2>

<ul>
	<li>ğŸŸ¦ <b>Arrays</b></li>
	<li>ğŸŸ© <b>Linked Lists</b></li>
	<li>ğŸŸ§ <b>Stacks</b></li>
	<li>ğŸŸ¨ <b>Queues</b></li>
	<li>ğŸŸª <b>Heaps</b></li>
	<li>ğŸŒ³ <b>Binary Trees</b></li>
	<li>ğŸŒ² <b>Binary Search Trees</b></li>
	<li>ğŸ•¸ï¸ <b>Graphs</b></li>
</ul>

<h3>ğŸ”¹ 1. Arrays</h3>

<b>Implementation:</b>
<ul>
	<li>Static & dynamic arrays</li>
	<li>Insert, delete, search, resize</li>
</ul>

<b>Classical Problems:</b>
<ul>
	<li>ğŸ”„ Reverse array</li>
	<li>ğŸ” Rotate array (k steps)</li>
	<li>â“ Find missing number (1..n)</li>
	<li>â• Two Sum / Subarray sum</li>
	<li>ğŸ’ª Kadaneâ€™s algorithm (max subarray sum)</li>
	<li>ğŸ“Š Prefix sum problems</li>
</ul>

<b>Algorithms:</b>
<ul>
	<li>ğŸªŸ Sliding Window</li>
	<li>ğŸ” Binary Search (and variants: first/last occurrence, upper/lower bound)</li>
	<li>ğŸ§® Sorting (Quicksort, Mergesort)</li>
</ul>

<h3>ğŸ”¹ 2. Linked Lists</h3>

<b>Implementation:</b>
<ul>
	<li>Singly, Doubly, Circular LL</li>
	<li>Insert at head/tail/pos, delete, search</li>
</ul>

Classical Problems:

Reverse linked list (iterative + recursive)

Detect cycle (Floydâ€™s algo)

Merge two sorted lists

Remove nth node from end

Find middle node

LRU Cache (LL + HashMap)

Algorithms:

Fast/slow pointer (Cycle detection)

Mergesort on Linked List

ğŸ”¹ 3. Stacks

Implementation:

Array-based stack

Linked list stack

Classical Problems:

Balanced parentheses

Next greater element

Min stack (O(1) min)

Evaluate postfix/prefix expression

Largest rectangle in histogram

Algorithms:

Monotonic stack

Infix â†’ Postfix conversion

ğŸ”¹ 4. Queues

Implementation:

Array queue (circular queue)

Linked list queue

Deque (double-ended queue)

Classical Problems:

Implement stack using queues

Implement queue using stacks

Sliding window maximum (deque)

Rotten oranges (BFS)

First non-repeating character in stream

Algorithms:

BFS (graph/grid traversal)

Sliding window

ğŸ”¹ 5. Heaps (Priority Queue)

Implementation:

Min-heap & Max-heap

Heapify, insert, extract

Classical Problems:

Heap sort

Kth largest/smallest element

Merge k sorted arrays/lists

Top K frequent elements

Median of data stream

Algorithms:

Heapify (O(n))

Priority queue scheduling

ğŸ”¹ 6. Binary Trees

Implementation:

Node structure

Recursive/iterative traversals

Classical Problems:

Inorder, Preorder, Postorder, Level Order

Height/Depth of tree

Diameter of tree

Lowest Common Ancestor (LCA)

Path sum problems

Serialize & Deserialize tree

Algorithms:

DFS (recursive & iterative)

BFS level-order

Recursion + backtracking

ğŸ”¹ 7. Binary Search Trees (BST)

Implementation:

Insert, search, delete

Traversals

Classical Problems:

Validate BST

Kth smallest/largest element

LCA in BST

Convert sorted array to BST

Floor & Ceil in BST

Algorithms:

Inorder traversal = sorted order

Self-balancing trees (AVL, Red-Black â€“ advanced)

ğŸ”¹ 8. Graphs

Implementation:

Adjacency list & matrix

Directed / Undirected

Weighted / Unweighted

Classical Problems:

DFS, BFS

Cycle detection (directed/undirected)

Topological sort (DFS + Kahnâ€™s algo)

Shortest path: Dijkstra, Bellman-Ford

Minimum Spanning Tree: Kruskal, Prim

Connected components (Union-Find, DFS)

Bipartite check

Bridges & articulation points (Tarjanâ€™s algo)

Algorithms:

Union-Find (DSU)

Dijkstra, Bellman-Ford, Floyd-Warshall

Kruskal, Prim

Tarjanâ€™s SCC

Kosarajuâ€™s SCC

âœ… Goal

Implement all data structures from scratch

Solve their classical problems

Master the algorithms built on top